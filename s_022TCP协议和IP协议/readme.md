## TCP/IP协议

### 1.TCP/IP协议（协议集)

传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议，由网络层的IP协议和传输层的TCP协议组成， 它规范了网络上所有的通信设备，尤其是一个主机到另一个主机之间的数据往来格式和传送方式。

TCP/IP协议的四层：![层级关系](层级关系.jpg)

OSI参考模型：开放式通信系统互联参考模型，是一个试图使各种计算机在世界范围内互连为网络的标准框架

- **1.1 TCP/IP协议参考模型：**

> **应用层:**向用户提供一组常用的应用程序，比如电子邮件、文件传输访问，远程登陆等；应用层包含了所有的高层协议，如FTP、TELNET、DNS、SMTP、RIP、NFS、HTTP。
>
> **传输层（TCP/UDP）**：提供应用程序之间通信，传输协议的选择根据数据传输方式而定，有传输控制协议TCP和用户数据报协议UDP
>
> **网络层(IP协议、ARP协议等)**：提供不同主机之间的通信，主要是1、处理来自传输层的分组发送请求2、处理输入数据包3、处理路径、流控、拥塞等问题
>
> **数据链路层**：负责数据帧的发送和接收，帧是独立的网络信息传输单元。网络接口层将帧放在网上，或从网上把帧取下来

- **1.2 TCP协议：是一种面向连接的、可靠的、基于字节流的传输层协议**

 所谓的字节流服务（Byte Stream Service）是指为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。

- **1.3 TCP和UDP的区别**

TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。

### 2.TCP协议的三次握手和四次挥手

#### 三次握手（建立连接的时候）

- **2.1首先介绍一下数据传输包中的标志位和序号，理解这些字段才能真正的理解三次握手**

（1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
（2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：

```
（A）URG：紧急
（B）ACK：确认
（C）PSH：传送
（D）RST：重置连接。
（E）SYN：发起一个新连接。
（F）FIN：释放一个连接。
```

- **2.2 三次握手具体的过程**

（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了

- **2.3整个过程是由客户端客户端执行connect()时。将触发三次握手。**

![三次握手](三次握手.png)

#### 四次挥手（释放连接的时候）

  由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭
 （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送（让Server关闭连接），Client进入FIN_WAIT_1状态。[**服务器读通道关闭**]

  （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态（Server准备好关闭了）。[**客户机写通道关闭**]

 （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送（告诉Client也要关闭连接），Server进入LAST_ACK状态。[**客户机读通道关闭**]

  （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态（关闭了连接），接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态（Server见Client关闭了连接，它也就关了），完成四次挥手。

[**服务器写通道关闭**]

**注意：整个过程是任何一方执行close()操作即可产生挥手操作。** 

![四次挥手_Ink_LI](四次挥手_Ink_LI.jpg)

###3.常见的状态码

> 状态码分为以下几类：
>
> 1xx：代表服务器收到请求，需要请求者继续执行操作
>
> 2xx：成功，操作被成功接收并处理
>
> 3xx：重定向，需要进一步的操作以完成请求
>
> 4xx：客户端错误，请求包含语法错误或无法完成请求
>
> 5xx：服务器错误，服务器在处理请求的过程中发生了错误
>
> 具体常见的如下：
>
> 100：Continue，服务器已收到请求，客户端需要继续发送请求
>
> 200：OK，请求成功。一般用于GET与POST请求
>
> 204：No Content，服务器成功处理，但未返回内容。
>
> 206：Partial Content，服务器成功处理了部分GET请求，断点续传会使用这个状态码
>
> 301：Moved Permanently，永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
>
> 302：Found，临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
>
> 304：Not Modified，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。户端通常会缓存访问过的资源
>
> 305：Use Proxy，使用代理。所请求的资源必须通过代理访问
>
> 400：Bad Request，客户端请求的语法错误，服务器无法理解
>
> 401：Unauthorized，未授权，请求要求用户的身份认证
>
> 403：Forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求
>
> 404：Not Found，服务器无法根据客户端的请求找到资源（网页）
>
> 405：Method Not Allowed，客户端请求中的方法被禁止
>
> 500：Internal Server Error，服务器内部错误，无法完成请求
>
> 502：Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
>
> 505：HTTP Version not supported，服务器不支持请求的HTTP协议的版本，无法完成处理

### 4.常见的HTTP请求方法

>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
>
>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。
>
>GET：请求指定的页面信息，并返回实体主体。
>
>HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
>
>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
>
>PUT：从客户端向服务器传送的数据取代指定的文档的内容。
>
>DELETE：请求服务器删除指定的页面。
>
>OPTIONS：允许客户端查看服务器的性能。
>
>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
>
>TRACE：回显服务器收到的请求，主要用于测试或诊断。

### 5.HTTP各版本之间的区别

>**HTTP/0.9**(第一个版本的HTTP协议，已过时)
>
>1.只允许客户端发送GET这一种请求，且不支持请求头，由于没有协议头，造成了HTTP/0.9协议只支持一种内容，即纯文本。
>
>2.链接无状态，每个事务独立进行处理，事务结束时就释放这个链接
>
>3.如果请求的页面不存在，也不会返回任何错误码
>
>**Http 1.0**
>
>1.增加了请求方式POST和HEAD
>
>2.请求与响应支持头域，有了头部信息，所以可以定义Content-Type，可以支持多种数据格式，开始支持cache
>
>3.支持长链接，可以定义一个非标准的`Connection`字段，设置Connection: keep-alive，一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。
>
>**Http 1.1**
>
>1.默认是长链接，在HTTP1.1中默认开启Connection：keep-alive，一个TCP连接可以允许多个HTTP请求；客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接。
>
>2.加入了管道机制，在同一个TCP连接里，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率，但是服务器还是按照顺序。
>
>3.客户端请求的头信息新增了`Host`字段，用来指定服务器的域名。因为一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址，所以发送的时候要制定。
>
>4.加入了一个新的状态码100（Continue）
>
>客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。
>
>5.加入了一些cache的新特性，引入了实体标签，一般被称为e-tags
>
>6.支持传送内容的一部分，支持断点续传
>
>客户端已经有了一部分内容，只需要跟服务器请求另外的部分资源即可，只需要跟服务器请求另外的部分资源即可。HTTP/1.0每次传送文件都是从文件头开始，即0字节处开始。RANGE:bytes=XXXX表示要求服务器从文件XXXX字节处开始传送，断点续传。即返回码是206（Partial Content）
>
>7.新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
>
>**Http 2.0**
>
>1.增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题
>
>2.增加服务器推送的功能，即不经请求服务端主动向客户端发送数据
>
>3.HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。
>
>4.引入了头信息压缩机制，一方面，头信息使用`gzip`或`compress`压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

### 6.浏览器的缓存机制

+ **使用缓存带来的好处：**

  + 减少网络带宽的消耗
  + 降低服务器的压力
  + 减少网络延迟，加快页面打开速度

+ **浏览器缓存的策略**

  + 缓存策略

    浏览器的缓存策略分为两种：强缓存和协商缓存，其中强缓存优先于协商缓存，强缓存失败之后才进行协商缓存，强缓存和协商缓存都是通过设置HTTP请求的header里的字段来实现的。

    浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，**浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的**。

    >1.浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
    >
    >2.浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

  + 强缓存

    强缓存的意思是浏览器不向服务器发起请求，直接从缓存中读取资源，强缓存可以通过设置两种 HTTP Header 实现，**Expires 和 Cache-Control。**

    >1.Expires
    >
    >缓存的过期时间，用来制定了资源的到期时间，是相对于服务器的具体时间点。**Expires=max-age + 请求时间，需要和Last-modified结合使用。**Expires是Web服务器**响应消息头字段**，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。**Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效**。
    >
    >2.Cache-Control
    >
    >在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：
    >
    >![cache-control](cache-control.jpg)
    >
    >public：所有内容都将被缓存（客户端和代理服务器都可缓存）。
    >
    >private：所有内容只有客户端可以缓存，Cache-Control的默认取值。
    >
    >**no-cache**:客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的强缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。
    >
    >**no-store**：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
    >
    >**max-age**：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效
    >
    >3.强缓存和协商缓存的区别：
    >
    >Expires 是http1.0的产物，Cache-Control是http1.1的产物，**两者同时存在的话，Cache-Control优先级高于Expires**；

  + 协商缓存

    协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：协商缓存生效，返回304，告知浏览器使用缓存资源；协商缓存失败，返回200，返回更新之后的资源信息。

    协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 

    >1.Last-Modified和If-Modified-Since
    >
    >浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；
    >
    >浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200
    >
    >2.Last-Modified 存在一些弊端
    >
    >因为 Last-Modified 只能以秒计时，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度
    >
    >如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存
    >
    >3.ETag和If-None-Match
    >
    >**Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成**
    >
    >浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。
    >
    >4.Last-Modified 和 ETag 的区别
    >
    >首先在精确度上，Etag要优于Last-Modified
    >
    >其次在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
    >
    >第三在优先级上，服务器校验优先考虑Etag

  + 缓存使用场景

    + 频繁变动的资源（Cache-Control: no-cache）

      对于频繁变动的资源，首先需要使用`Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。

    + 不常变化的资源（Cache-Control: max-age=31536000）

      通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 `max-age=31536000` (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效。

###7.