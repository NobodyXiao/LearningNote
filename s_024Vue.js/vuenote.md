## 学习vue的记录##

别人嘲笑的不是你的梦想，而是你的实力；自律才自由，自律是战胜拖延症的法宝，是实现一切梦想的前提。

1. #### 使用vue的常见方法####

   a.使用独立版本，引入cdn，在开发过程中要使用开发版本，因为遇到错误，它会给出友好提示。

   b.使用npm进行安装，`npm install vue`,构建大型项目的时候使用这种方法能很友好的与Webpack\Browserify混合使用。

2. #### 关于使用npm方式构建vue的时候，独立构建和运行时构建的不同####

   两种方式的区别在于前者包括模版编译器，而后者不包括；模版编译器的作用是用于将vue模版字符串变异成js渲染函数，即template模版字符串。

   Vue.js 的运行过程实际上包含两步。第一步，编译器将字符串模板（template）编译为渲染函数（render），称之为编译过程；第二步，运行时实际调用编译的渲染函数，称之为运行过程。

   由于 Vue.js 1.0 的编译过程需要依赖浏览器的 DOM，所以无法（或者说没有意义）将编译器和运行时分开。因此在 Vue.js 1.0 分发包中，编译器和运行时是打包在一起，都在浏览器端执行。

   然而到了 Vue.js 2.0，为了支持服务端渲染（server-side rendering），编译器不能依赖于 DOM，所以必须将编译器和运行时分开。这就形成了独立构建（编译器 + 运行时）和运行时构建（仅运行时）。显而易见，运行时构建要小于独立构建。

3. **vue的属性和方法**

   3.1每个vue实例都会代理其data对象中的所有属性，只有这些被代理的属性是响应的，如果在实例创建之后，添加属性上去，那么久不会触发视图更新。

   ```
   var data = { a: 1 }
   var vm = new Vue({
     data: data
   })
   vm.a === data.a // -> true,此时的vue实例等于上边定义的data对象
   ```

   3.2除了data属性之外，vue还暴漏了一些实例的属性和方法，这些属性和方法之前都要加上$,以便与代理区的data属性区分

   其中不要在实例属性和回调函数中使用箭头函数，因为箭头函数绑定父上下文，所以this不会像预期一样是vue实例，而且this.myMethod未被定义。

   ```
   var data = { a: 1 }
   var vm = new Vue({
     el: '#example',
     data: data
   })
   vm.$data === data // -> true
   vm.$el === document.getElementById('example') // -> true,指明vue元素绑定的元素
   // $watch 是一个实例方法
   vm.$watch('a', function (newVal, oldVal) {
     // 这个回调将在 `vm.a`  改变后调用
   })
   ```

4. 实例的生命周期

   每个vue实例在被创建之前都要经过一系列初始化过程。例如实例需要**配置数据观测**，**编译模版**，**挂载实例到DOM**，然后在**数据变化时更新DOM**。在这个过程中，实例也会调用一些生命周期钩子，这就给我们提供了自定义逻辑的机会。例如created这个钩子在实例创建之后被调用：

   ```
   var vm = new Vue({
     data: {
       a: 1
     },
     created: function () {
       // `this` 指向 vm 实例
       console.log('a is: ' + this.a)
     }
   })
   // -> "a is: 1"
   ```

   也有一些其他钩子，在实例周期的不同阶段被调用，比如mouted，updated，destroyed，钩子的**this指向调用它的vue实例**。

5. ​

   ​

   ​

